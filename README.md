# Overview

This is a Spring Boot application that implements basic RESTful API endpoints to get the transactions back.

The transaction data are stored in a Kafka topic whose the retention period is set to infinite so that data will NOT be purged.

To facilitate the search requirements, additional streams and tables are built in KsqlDB accordingly.

## Performance Consideration

The transaction records are stored in a Kafka topic. The transaction details are stored as message body in JSON format.

A data stream is created in KsqlDB from the topic with the timestamp being the transaction date. By extract the data foom the message body, each record contains the account number, value date and value timestamp among with other information.

A table is then created to group the data from the stream by user ID, account number and value date. In other words, each record contains all the transactions a user's account for a particular day. The records are stored in chronological order of the transaction date.

The following SQL statement find the transaction for a user's account within the given date range.

```roomsql
SELECT
    user_id,
    value_date,
    daily_transactions
FROM transactions_by_user_value_date
WHERE user_id = @user_id
AND account_number = @account_number
AND value_date BETWEEN @startdate_timestamp AND @enddate_timstamp
```

The Java client reads the data through stream. Each record contains all the transaction data for that particular day. As long as enough number of transactions are read, it stops and sorts the transaction records locally before returning to the client.

A special value called offset can be provided as a particular parameter in the API call. This is the value timestamp of the last transaction record in the previous call. Once it is provided, the date value of this timestamp will be used as the start date to fetch next batch of records and only transaction records with value timestamp greater than that offset will be included in the next batch of data.

This can dramatically reduce number of records to be fetched from KsqlDB table.
## Kafka

### Topics

account_transactions - Store the transaction data as message payload in JSON format
user_accounts - Associate users with accounts which in turns links to individual users

### KSQL Tables and Streams

user_accounts_table - Table with data coming from the user_accounts topic

account_transactions_stream - Stream that access transactions data from the topic

user_account_transactions_stream - Stream that links up transaction data with users information by joining the transaction stream and user table in KsqldB

transactions_by_user_value_date - Table that group transactions by days and users to support query of transactions per day.

In Kafka stream, it is not possible to select and return data in a particular order. In order to display all the transactions happened within a period of time, it is nscessary to download all of them and sort them in proper order. This will be inefficient for a large database.

Since we group all the transactions per day in transactions_by_user_value_date table, data can be downed in batch (.e.g per day) and sort them. This can drmatically reduce the volume of data for processing.

To further improve the performance, we can consider the following settings

1. Store data evenly in different partitions of the topic to allow parallel access.
2. Store data in different topics, one per year or even one per month

Details of the Kafka setup can be found in this [readme](docs/kafka.md) file.

### Generate Sample Data

Sample data is generated by a [Python program](scripts/generate-accuont-transactions.py). The program generates sample data in a CSV file.

```bash
cd scripts
python generate-account-transactions.py [optional filename of the output file]
```

### Import data to Kafka topics

With cli profile, the Spring Boot application will read the data from file and pssh them to the KaKfa topics.

The only argument of the command is the location of the configuration file which in turns defines the location of data file, the topic names.

The mapping of the user account and transaction data are stored in a separate topic. From Kafka perspective, the association should be created before the transactions. THerefore, it is necessary to explicitly specify the timestamp which is also defined in the configuration file.


```bash
./gradlew bootRunCli -Pargs="-i load-data.json"
```

## SQL Database

User data is stored in a SQL database. For simplicity, H2 in memory database is used. Both [schema](src/main/resources/schema.sql) and [initial data] (src/main/resources/data.sql) are provided.

The preferred currency is stored in the SQL database and used to do the foreign exchange copmputation in transaction listing.

### Exchange rates

Exchange rates are provided by third party via RESTful API.

Since exchange rates are not updated very often, to reduce network overhead and increate the stability, exchange rates data retrieved form the API and stored in a local database.

Spring in Cache was enabled to store exchange rates in Redis. Therefore data will be retrieved from Cache most of the time. Database will be used only when the cache is not ready.

Update of the cache data via API calls are handled in a separate standalone [job](java/com/ntunghoi/kafkaapp/jobs/ExchangeRatesLoader.java). When new data is retrieved from the API endpoint, records in database and cache will be updated.

# Produce to try

1. Run gradlew command to start the Spring Boot application.

```bash
# in project root folder
./gradlew bootRun
```

2. Access the API documentation

http://localhost:8085/swagger-ui/index.html

3. Access the API endpoints

Here is a sample data file (e.g. registration.json) for registration

```json
{
  "confirm_password": "password123",
  "email": "user9@email.com",
  "name": "Peter Parker",
  "password": "password123"
}
```

```bassh
# Registration
curl -X POST http://localhost:8085/auth/login -d @registration-request.json -H 'Content-Type: application/json'

```

A number of predefined user accounts are created as defined in the database initialization script [here](src/main/resources/schema.sql)

```baseh

# Log in
# Get the JWT value in the response
curl -v -X POST localhost:8085/auth/sessions -d '{"email": "user3@email.com", "password": "password123"}' -H 'Content-Type: application/json'
# Set the JWT in an environment variable
set BEARER=

# Get transactions data
curl -v 'http://localhost:8085/accounts/transactions?account_number=GB84CPBK83157663644901&start_date=2024-01-01T00:00:00&end_date=2024-01-31T00:00:00&size=20' -H "Authorization: Bearer $BEARER"| jq .
```

# Testing

Run the following command to run the tests

```bash
./gradlew test
```

Open the report page [here](build/reports/tests/test/index.html)